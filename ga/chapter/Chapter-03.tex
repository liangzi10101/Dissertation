\setcounter{chapter}{2}

\chapter{基于特征空间划分的算法级绘制性能瓶颈识别}
\label{sec:CoreAlgorithm}

本章主要对基于特征空间划分的算法级绘制性能瓶颈识别技术进行了详细的介绍分析。首先，提出基于瓶颈分析树进行特征空间划分的基本思想以及实现流程，然后引出构建瓶颈分析树的难点，进一步介绍本文两种不同的实现方案：贪心策略与类遗传策略。在分析贪心策略构建瓶颈分析树时出现的问题以及产生问题的根本原因之后，详细讨论了类遗传策略解决问题的理论依据与基本思想；第三步，重点讨论本文基于类遗传策略的性能瓶颈识别技术需要解决的关键问题；第四步，针对关键问题详细阐述了算法的具体实现流程与相关实现细节；最后对本章进行简要总结。

\section{算法概述}

\subsection{瓶颈分析树}

\subsubsection{问题描述}

本文核心算法提出的目的是为了解决在完整性能数据集上无法确定全局性能瓶颈的情况。其基本思想是：通过特征超平面对数据所在的特征空间进行划分，使得原始性能数据集被划分到了不同的子特征空间形成子数据集，以完成各子空间中“局部性能瓶颈”确定工作。

其理论依据在于：超平面划分可能进一步简化子数据空间中“特征”与“结果”影响关系，为了进一步解释该依据，本文将该瓶颈识别问题与C.Cooper等人寻找最影响人类幸福指数因素的研究\cite{Cooper2011Happiness}进行类比。在对人类幸福感的研究中，C.Cooper提出：事实上很难找到一个普适性的决定因素影响人类幸福感，因为从整体上来看，众多因素（例如性别、宗教、健康状况、收入等）均会影响到人类幸福感的判定，而这些因素影响的程度可能不会有明显差异。但是假设按照人类的年龄段这一特征将人类进行划分时，可能很容易确定出影响人幸福感的决定性因素。C.Cooper等人在其研究中指出：亲密关系和好友的数量是影响16-59岁人群其幸福感的最重要因素，而婚姻对60-79岁人群的幸福感影响最大，对于79 岁以上的人群而言，最重要的影响因素是参加宗教活动的频率。

瓶颈分析树是对特征空间划分过程以及数据集划分结果的表示，构建瓶颈分析树的过程就是完成本文核心算法的过程。在具体阐述瓶颈分析树的具体实现流程\ref{}前，首先简要回顾一些基本概念。

假设一个包含有$M$个绘制算法（记为：$A_1, A_2, ..., A_M$）的复杂绘制系统$\mathfrak{R}$，其中每个算法$A_i(i=1, 2, ..., M)$包含有若干个影响绘制性能的算法级参数（$\mathbf{p}_i^1, \mathbf{p}_i^2, ...$）。所有这些包含于$\mathfrak{R}$的算法级参数（假设有$N$个）构成当前研究问题域的\textbf{参数集}，记为：$\mathbf{P}=\{\mathbf{p}_1, \mathbf{p}_2, ..., \mathbf{p}_N\}$。 假设任意算法级参数$\mathbf{p}_i\in \mathbf{P}$拥有其有效取值的集合$\mathbf{V}(\mathbf{p}_i)$，则有\textbf{参数空间}：$\mathbb{P}=\{\mathbf{V}(\mathbf{p}_1)\times \mathbf{V}(\mathbf{p}_2)\times ... \times \mathbf{V}(\mathbf{p}_N)\}$，该参数空间包含参数集$\mathbf{P}$所有参数$\mathbf{p}_i$其有效取值所有可能的组合。

本文延续采用前期工作\cite{Zhang:2018:AIP:3208159.3208178}提出的回归森林\cite{Breiman2001Random}构建描述参数集$(\mathbf{p}_1, \mathbf{p}_2, ..., \mathbf{p}_N)$与绘制时间$t$之间非线性关系的估计模型$\mathcal{F}(\mathbf{p}_1, \mathbf{p}_2, ..., \mathbf{p}_N)=t$。基于回归森林，性能瓶颈的识别工作可以转化为算法级参数$\mathbf{p}_i$对响应变量$t$的\textbf{变量重要性}(Variable importance, VI) 测量工作\cite{Chang2008Feature}\cite{Gr2015Variable}。 变量重要性方程$\mathbf{I}(\mathbf{p})$用来计算参数$p$的VI得分$s_\mathbf{p}$，以定量测量参数$\mathbf{p}$对$t$的影响程度。

\begin{figure*}[!htb]
	\centering
	\subfigure{
		\includegraphics[scale=0.13]{figures/Figure1_a.png}
		\label{Fig.BasicIdea_a}
	}
	\subfigure{
		\includegraphics[scale=0.13]{figures/Figure1_b.png}
		\label{Fig.BasicIdea_b}
	}
	\subfigure{
		\includegraphics[scale=0.13]{figures/Figure1_c.png}
		\label{Fig.BasicIdea_c}
	}
	\caption{识别瓶颈的基本思想. (a) $\mathbf{\tilde{p}}_1$和$\mathbf{\tilde{p}}_2$被识别为瓶颈. (b) $\mathbf{\tilde{p}}_1$和$\mathbf{\tilde{p}}_2$不是瓶颈，原因是$\mathbf{\tilde{p}}_2$与$\mathbf{\tilde{p}}_3$的落差值小于阈值. (c) $\mathbf{\tilde{p}}_1$, $\mathbf{\tilde{p}}_2$, $\mathbf{\tilde{p}}_3$, $\mathbf{\tilde{p}}_4$均不是瓶颈，原因是它们的个数总和超出了限定阈值.}
	\label{Fig.BasicIdea}
\end{figure*}

一旦每个算法级参数的VI得分被计算出来，所有参数根据其VI值按降序排序，降序后的参数集记为：$(\mathbf{\widetilde{p}}_1, \mathbf{\widetilde{p}}_2, ..., \mathbf{\widetilde{p}}_N)$，之后，性能瓶颈集可以按照如下方式完成定义。如图\ref{Fig.BasicIdea}所示，假设VI 得分的最大落差存在于$\mathbf{\widetilde{p}}_i$和$\mathbf{\widetilde{p}}_{i+1}$之间（例如图\ref{Fig.BasicIdea_a}中的$\mathbf{\widetilde{p}}_2$和$\mathbf{\widetilde{p}}_3$，图\ref{Fig.BasicIdea_c}中的$\mathbf{\widetilde{p}}_4$和$\mathbf{\widetilde{p}}_5$）则前$i$个参数如果满足公式\ref{eq:bottleneck}，则称这$i$个参数为性能瓶颈：

\begin{eqnarray}\label{eq:bottleneck}
	i<\epsilon_1 \nonumber \\
	s_{\mathbf{\tilde{p}}_i}-s_{\mathbf{\tilde{p}}_{i+1}}>\epsilon_2
\end{eqnarray}
其中$\epsilon_1$和$\epsilon_2$是用户定义的阈值.

实际上，根据公式(\ref{eq:bottleneck})的定义并不能保证非空的瓶颈集一定存在。图\ref{Fig.BasicIdea_b}描述了这样一种情况：当各参数的VI 得分不存在明显最大落差时，这意味着所有参数对系统绘制效率的影响不存在明显差异；而图\ref{Fig.BasicIdea_c}则展示了另一种瓶颈识别失败的情形：数量过多的参数均对系统绘制性能造成明显影响，这时依然无法确认绘制系统的性能瓶颈是什么。

\subsubsection{实现流程}

本文构建瓶颈分析树的工作流程如下：

\begin{itemize}
    \item 预采集得到一组\textbf{性能数据集}$\mathcal{P}=\{(p_1^i, p_2^i, ..., p_N^i, t_i)\}$，其中$(p_1^i, p_2^i, ..., p_N^i)$是当前参数空间$\mathbb{P}$下的一次有效取值，$t_i$则是在当前有效取值$(p_1^i, p_2^i, ..., p_N^i)$下测量得到的相应绘制时间。换言之，性能数据集$\{(p_1^i, p_2^i, ..., p_N^i, t_i)\}$可以被视为当前参数空间$\mathbb{P}$以及绘制系统$\mathfrak{R}$下的一次采样；

	\item 构建回归森林以评估算法级参数（参数集$\mathbf{P}$）与绘制性能（绘制时间$t$）之间的非线性关系模型；

    \item 根据不同策略（具体参见\ref{sec:genBAT}、\ref{sec:genBATga}小节）选取划分超平面将采样得到的性能数据集$\mathcal{P}$划分到若干个子数据集，保证在每个子数据集中均可利用上述同样的基于变量重要性的方法找到该子数据集下的局部性能瓶颈；

\end{itemize}

本文提出利用对特征属性的布尔逻辑判断完成对性能数据所在空间的划分以构建瓶颈分析树。特征属性的布尔逻辑判断就是本文使用的特征超平面，得到的瓶颈分析树本质上是一个二叉树。

\begin{figure}[!h]
	\centering{
	\includegraphics[width=1.0\linewidth]{figures/splitPlane.png}}
	\caption{布尔特征超平面的原理.}
	\label{Fig.splitPlane}
\end{figure}

图\ref{Fig.splitPlane}以三维空间为例进行简要说明，假设当前问题域空间存在3 个特征属性（分别记为$\mathbf{x}, \mathbf{y}, \mathbf{z}$），黑色圆点表示在当前空间下采样得到的数据集，节点A首先选取特征属性$\mathbf{z}$作为划分特征，$z_1$为划分点进行布尔条件判断，以是否满足$\mathbf{z}> z_1$为判断标准将节点A划分为节点B和节点C。 递归完成：节点B选取特征属性$\mathbf{x}$作为划分特征，$x_1$为划分点将节点B划分为节点D 和节点E。

将问题拓展至高维空间，瓶颈分析树的具体生成过程为：根据当前绘制系统的复杂程度确定瓶颈分析树的最大树深，记为$D_M$，将预采集的完整性能数据集作为瓶颈分析树的根节点数据，并以此作为起始，按照一定方式选择划分特征（参数集$\mathbf{P}$中的任意参数$\mathbf{p}_i$）和划分点（参数$\mathbf{p}_i$对应有效取值$p_i^j$），划分得到两个左右子节点尝试确定是否满足终止条件，即：其局部空间内根据变量重要性计算找到瓶颈。如果满足，则终止划分，否则继续子节点的划分过程直至其节点深度达到$D_M$。

\subsection{贪心策略构建瓶颈分析树}
\label{sec:genBAT}

\subsubsection{问题描述}

构建瓶颈分析树的难点在于：按照怎样的方式选取划分特征以及划分点，使得瓶颈分析树的各个叶子节点内均能够确定出局部性能瓶颈。不合理的划分方式极其容易得到划分形态不好的瓶颈分析树。划分形态的优劣主要体现在以下两个方面：

\begin{itemize}
    \item 瓶颈分析树叶子节点的局部性能瓶颈中，参数的个数偏大，更趋向于用户指定的阈值，这不利于开发过程中的优化，因为优化过程期望性能瓶颈中涉及到的算法级参数越少越好。如图\ref{Fig.BadTree01}所示，用户期望每个局部的瓶颈至多为2 个，对于图\ref{Fig.BadTree01_a}来说，当前的划分平面$H$导致叶子节点$D$的性能瓶颈有2 个，而\ref{Fig.BadTree01_b}中，选取另一个划分平面$H^{'}$进行数据划分后，叶子节点$D$的性能瓶颈仅有1 个；

    \item 瓶颈分析树非叶节点在进行数据划分时，其左右子节点数据量的极度不平衡导致分析树的某一侧健壮，而另一侧迅速萎缩，事实证明这并不利于进一步探索局部性能瓶颈。如图\ref{Fig.BadTree02_a}所示，节点$B$包含6000个采样数据量，即使当前节点无法确定出局部瓶颈，但将其继续划分，其任意子节点拥有的数据量必然小于预先设定的阈值5000，因此划分失败，这成为枝干的萎缩。而枝干萎缩的情况出现越多，则当前二叉树形态越差，极端情况下会出现数量巨大的萎缩节点，这不利于确定局部性能瓶颈。而\ref{Fig.BadTree02_b}中，该瓶颈分析树的各个枝干较为平衡，其叶子节点总个数为4 个，而每个叶子节点均可以确定其局部性能瓶颈，这被认为是形态好的分析树。
\end{itemize}

\begin{figure*}[!htb]
	\centering
	\subfigure{
		\includegraphics[scale=0.16]{figures/BAT_bad_01_a.png}
		\label{Fig.BadTree01_a}
	}
	\subfigure{
		\includegraphics[scale=0.16]{figures/BAT_bad_01_b.png}
		\label{Fig.BadTree01_b}
	}
	\caption{不同划分结果一. (a) 该叶子节点内需要优化的参数有两个：$p_1, p_2$. (b) 该叶子节点内需要优化的参数有一个：$p_1$.}
	\label{Fig.BadTree01}
\end{figure*}

\begin{figure*}[!htb]
	\centering
	\subfigure{
		\includegraphics[scale=0.16]{figures/BAT_bad_02_a.png}
		\label{Fig.BadTree02_a}
	}
	\subfigure{
		\includegraphics[scale=0.16]{figures/BAT_bad_02_b.png}
		\label{Fig.BadTree02_b}
	}
	\caption{不同划分结果二. (a) 该瓶颈分析树左端健壮，右端萎缩. (b) 该瓶颈分析树枝干平衡.}
	\label{Fig.BadTree02}
\end{figure*}

\subsubsection{原因分析}

上述原始的瓶颈分析树生成过程很容易得到划分形态不好的瓶颈分析树，其根本原因在于对划分超平面（划分特征和划分点）的全随机选择。这种方式不考虑选取的划分超平面对划分结果的影响，包括划分后子空间各自拥有的数据量、以及子空间是否可以确定出局部性能瓶颈，而这些均对瓶颈分析树的生成起指导性作用。

\subsubsection{贪心策略}

本文基于贪心策略构建瓶颈分析树，充分考虑划分平面对空间划分结果的影响，利用贪心策略为划分超平面的选取制定标准，该标准指出：选取划分特征以及对应划分点，应尽可能使得当前节点划分得到的子节点能够尽可能确定出局部性能瓶颈（瓶颈个数越少越好）且左右子节点的数据量不出现严重失衡。

充分考虑到上述两点因素，本课题提出基于贪心策略构建瓶颈分析树。其实现过程为：将当前数据集所在的节点作为研究节点，计算该节点各参数的变量重要性数值，若根据变量重要性并结合公式\ref{eq:bottleneck}能够分析出性能瓶颈，则结束整个流程。否则，遍历当前节点所有可能的划分超平面$\mathcal{H}$，利用本文提出的对超平面划分结果进行评估的评估函数$\mathfrak{S}(\mathcal{H})$完成对该划分超平面的分数评估，从中选取$\mathfrak{S}(\mathcal{H})$得分最高的划分分超平面作为当前节点最佳划分策略。重复上述过程，直到所有节点均找到局部性能瓶颈。其中$\mathfrak{S}(\mathcal{H})$充分考虑划分后左右子节点中重要参数的个数以及左右子节点内数据量平衡与否。重要参数的个数就是公式\ref{eq:bottleneck}中的$i$。

\begin{equation}
\label{eq:BestSplitPlane}
\mathfrak{S}(\mathcal{H})=s(\mathcal{D}^L_\kappa)+s(\mathcal{D}^R_\kappa)
\end{equation}
其中，$\mathcal{D}^L_\kappa$和$\mathcal{D}^R_\kappa$是当前节点数据集$\mathcal{D}_\kappa$划分成的两个子数据集。而得分方程$s(\mathcal{D}_\kappa)$又被定义为如下形式：

\begin{equation}\label{eq:EvaluationScore}
s(\mathcal{D}_\kappa) =
  \left \{
   \begin{array}{lcl}
   1.0&      & {\mathbf{P}_B^{\mathcal{D}_{\kappa}}\neq \emptyset}\\
   \frac{\sum\limits_{i=1}^b\mathbf{I}^{\mathcal{D}_\kappa}(\mathbf{p}'_i)}{\sum\limits_{i=1}^N\mathbf{I}^{\mathcal{D}_\kappa}(\mathbf{p}'_i)}&      & {\mathbf{P}_B^{\mathcal{D}_{\kappa}}= \emptyset}\\
   \end{array}
   \right.
\end{equation}
其中$\mathbf{I}^{\mathcal{D}_\kappa}(\mathbf{p}'_i)$表示当前各参数变量重要性数值按降序排列之后第$i^{th}$大的变量重要性数值，$b$表示变量重要性最大落差值之前参数的个数，$N$表示参数总个数，$\mathbf{P}_B^{\mathcal{D}_{\kappa}}$表示在数据$\mathcal{D}_{\kappa}$下的性能瓶颈集合，该集合有可能为空当不满足公式\ref{eq:bottleneck}时。

\subsection{类遗传策略构建瓶颈分析树}
\label{sec:genBATga}

通过上一节对基于贪心策略构建瓶颈分析树其基本原理的介绍以及对其基本流程的再现实验，我们发现上述策略在性能识别过程中存在以下两个重要的问题：

\subsubsection{问题描述}

基于贪心策略构建瓶颈分析树，在其构建分析树时并没有一种寻找全局最优算法倾向，其划分结果往往不一定具备好的指导结果。具体来说，贪心策略构建瓶颈分析树，在选择划分点将当前数据空间划分为两个子空间时，总是选择使得两个子空间中占据重要变量的参数个数之和最少的划分点，并重复该过程直到在子空间找到局部性能瓶颈或子空间不可继续再被划分，这是局部最优解。实验表明，以贪心方式构建的瓶颈分析树总是无法找到更好的瓶颈分析树。

\subsubsection{原因分析}

该问题产生的根本原因在于：绘制性能数据的划分过程并不一定具备最优子结构性质，它跟所采集场景的复杂程度有关，最优子结构性质保证问题的最优解包含子问题的最优解，但当绘制场景的复杂度进一步增加时，往往无法保证最优子结构特性，因而利用贪心策略构建瓶颈分析树无法找到更优解。

\subsubsection{问题描述}

基于贪心策略构建瓶颈分析树产生的第二个问题是构建的瓶颈分析树形态不稳定，即：重复瓶颈分析过程，得到的特征空间划分结果以及对应的识别到的瓶颈可能会不稳定。具体来说，在特征空间划分的过程中，存在若干方案满足目标划分结果，贪心策略对其任一划分结果完成评估，并总是在这些划分结果中选取得分最高的一个方案作为最终结果。事实上，这些方案的评分结果会出现合理浮动，这将导致得分最高的划分方案并不总稳定在某一种划分结果上，这导致该策略最终确定的方案其瓶颈分析树形态不稳定。

\subsubsection{原因分析}

造成这一问题的根本原因在于贪心策略对多个划分方案的非统计性选择以及潜在瓶颈（算法级绘制参数）变量重要性其计算数值的合理浮动，即：\textbf{误差内浮动}。变量重要性计算数值的误差内浮动是指：在预采集性能数据集一定，构建的回归森林性能评估模型稳定的前提下，根据评估模型下变量重要性计算原理计算得到的某参数变量重要性数值会在误差范围内上下浮动。当各参数对绘制性能的影响力相差较大时，其数值在误差范围内的浮动并不会影响瓶颈分析树的构建过程，但当各参数对绘制性能的影响力相差接近时，此时数值的浮动将直接影响到划分点的选取从而进一步影响瓶颈分析树的形态，因此有可能会得到若干个整体评估分数相近，但形态不同的瓶颈分析树。同时，又由于评估瓶颈分析树时，再次用到了该树各个叶子节点中各参数的变量重要性计算结果，这就导致这些性能瓶颈分析树的评估值出现浮动，最终导致贪心策略结果的不稳定性。

\subsubsection{类遗传策略}

本文提出的基于类遗传策略的瓶颈识别算法可以解决上述问题。该算法摒弃上述选择瓶颈分析树的方式，其基本思想是：将某种特征空间划分方案（具体表现为一个瓶颈分析树）抽象为一个生物个体，选取一定基数的生物个体构成一个完整的生物种群，该种群作为潜在最优解的问题解集，从该初始种群开始，选择适应度（参见章节\ref{sec:FitnessCalculate}）更高的生物个体作为父类，模拟遗传学机理的生物进化过程，借助自然遗传学的遗传算子（参见章节\ref{sec:GAOperator}）生成新的子类个体，再根据达尔文生物进化论的自然选择算子（参见章节\ref{sec:GAOperatorSelector}），不断筛选出适应度更高的生物个体进行保留，而淘汰适应度低的个体，并通过自然遗传学中的变异算子（参见章节\ref{sec:GAOperatorMutex}）保证种群的突变性和多样性，防止过早收敛于局部最优解的情况出现。以此循环完成种群的迭代，直至种群中所有个体的适应能力趋于收敛。整个过程将导致种群像自然进化一样，后代种群比前代更加适应于环境，末代种群中的统计得到的最优个体就是本文问题的近似最优解。

本文基于类遗传策略构建瓶颈分析树需要解决的难点是：

\begin{itemize}
	\item 初始种群规模在理想条件下应包含本文算法问题的所有解，但这样的种群规模对于计算效率和计算资源的占用是不切实际的，因此，如何保证在种群规模一定、尽可能在保证初始种群多样性和随机性的前提下，在所有问题解中选取一定规模的解集合作为初始种群，以满足加快种群寻找最优解进程的目标。换言之，如何保证初始种群个体多样性和随机性的同时，生成适应度较高的初始种群；
	\item 如何将不同的特征空间划分方案进行抽象，使得遗传算法的各个算子能够作用于划分方案的筛选和进化。类似自然界中遗传学的作用原理：交叉遗传算子并不直接作用于生物个体，而是通过生物个体的染色体进行优秀基因的交叉与保留的，本文将特征空间的划分方案作为遗传个体，则需要对划分方案进行抽象，抽象出能够唯一表示该个体的染色体序列，该过程的核心难点在于：瓶颈分析树个体的形态差异巨大，制定的染色体编码标准必须使得生成的染色体能够顺利地完成基因序列的等位交叉、重组；
    \item 设计合理的适应度函数以指导初始种群朝着预期目标方向进化收敛。个体适应度的评估在整个遗传算法中起到决定性作用，包括种群的收敛方向与收敛速度。因此，如何设计合理的个体适应度函数能够使得末代种群中的个体满足对最优解的要求也是本文重点需要解决的问题；
\end{itemize}

为解决上述关键问题，本文算法采用如下流程完成类遗传策略构建瓶颈分析树，核心部分包括创建初始种群、编码种群中的个体、构建适应度评估标准、进行遗传学交叉、选择、变异算子的操作完成新一代种群的生成，迭代此过程直至满足结束条件。本文算法实现流程如图\ref{Fig.flowchart_ga}所示：

\begin{figure}[!h]
	\centering{
	\includegraphics[width=.3\linewidth]{figures/FlowChart_ga.png}}
	\caption{类遗传策略整体流程图.}
	\label{Fig.flowchart_ga}
\end{figure}

图\ref{Fig.flowchart_ga}描述了伪遗传策略识别局部性能瓶颈算法的各个阶段。第一阶段完成规模为$N$的初始种群生成工作，其中$N$是一个预设的值，其具体数值根据当前问问题域的规模大小决定；初始种群的生成细节参见\ref{sec:GenInitialPopulation}；第二阶段完成中群内所有个体的编码工作，编码工作为每个生物个体生成唯一标识的染色体，该染色体成为交叉算子的具体载体；第三阶段，利用适应度函数评估生物个体对环境的适应能力，适应度值越高的个体表示其生存能力越强，被淘汰的几率越小，同时也间接说明其染色体中存在更优秀的基因片段；第四阶段，根据上一阶段个体适应度的评估结果，选择出一定比例的个体作为进行交叉算子的父类，父类集合不重复两两随机配对完成交叉生成新的$n$个染色体；第五阶段，根据新的n 个染色体完成解码，重新恢复出n 个新的个体，并完成新个体适应度的计算；第六阶段，在新旧个体共同构成的临时种群中完成选择算子，即：具有更高适应度值的个体有更大的几率存活下来，此筛选过程采用轮盘赌的方式进行，并最终淘汰$n$个个体，留下规模仍为$N$的个体；第七阶段，在当前种群中根据一定的变异率完成种群个体的变异过程以保证一定的随机性和多样性，防止过快收敛，此时得到的种群即为新一代种群；第八阶段完成迭代终止条件的判断，如果相邻两代种群的个体平均适应度差值小于预设阈值则进入第九阶段，否则继续转入第二阶段；第九阶段，与前文算法相比，我们不再关注单个瓶颈分析树的优劣，最终在末代种群中，统计分析适应度最高且出现次数最多的个体作为最终最优解输出，以此避免由于变量重要性计算的浮动造成的决策偏差。

\section{生成初始种群}
\label{sec:GenInitialPopulation}

\subsection{基本目标}

本文算法需要解决的第一个关键问题就是初始种群的生成。初始种群由一定规模的瓶颈分析树共同构成。瓶颈分析树的生成方式以及分析树规模共同决定一个初始种群的质量，而初始种群的质量将直接影响本文核心算法的结果。其原因在于：根据\ref{sec:genBATga}章所述，本文关注的问题属于NP问题，由于该问题的规模已经超出计算机在期望时间内决策的规模，因此不可能穷尽所有可能性，生成包含所有解的初始种群。相反，本文需要解决的问题是：在种群规模一定、保证初始种群多样性和随机性的前提下，在完整解集中，选取一定规模的解集合作为初始种群，以满足加快种群寻找最优解进程的目标。换言之，生成初始种群的基本目标是：如何保证初始种群个体多样性和随机性的同时，生成适应度较高的初始种群。

在提出本文生成初始种群算法前，首先回顾某个原始瓶颈分析树的生成过程：根据当前绘制系统的复杂程度确定瓶颈分析树的最大树深，记为$D_M$，将预采集的完整性能数据集作为瓶颈分析树的根节点数据，并以此作为起始，完全随机地选择划分特征和划分点，划分得到两个左右子节点尝试确定是否满足终止条件，如果满足，即：其节点深度达到$D_M$或者其局部空间内找到瓶颈，则终止进一步划分，否则继续子节点的划分过程。$N$个原始瓶颈分析树共同构成的初始种群被称为全随机初始种群。

分析全随机生成初始种群出现的问题：上述未优化的瓶颈分析树生成过程很容易得到划分方式不好的瓶颈分析树，其根本原因在于对划分特征的全随机选择。在这种方式下，当规模一定时，生成的瓶颈分析树很难涵盖完整解集中更多潜在的优质解，这将导致初始种群的个体适应度普遍偏低，因此直接导致整个遗传算法需要更多迭代次数以达到收敛，放缓了迭代速度。

除此之外，划分点的全随机选择也是另一个使得初始种群个体质量差的原因。划分点的完全随机选取有可能造成划分的左右子节点内数据量的严重不平衡，而变量重要性计算原理要求：提供变量重要性计算的数据量小于一定阈值时，变量重要性的计算结果将不再保证稳定性和正确性，这实际上造成了当前的瓶颈分析树是不合格的种群个体。实验2 关于变量重要性计算稳定性的实验给出了进一步验证和阈值的确认工作。

因此，为实现初始种群生成的基本目标，本文算法需要完成两点优化：划分特征的选择和划分点的选择。

\subsection{划分特征选择的优化}
\label{sec:SpliteFeature}

优化划分特征选择依据越重要的特征越应该被提前选为空间划分参数的原理改进了初代种群个体生成过程。具体来说，本文在随机选择非叶节点的划分特征时，使用当前非叶节点所有特征变量重要性数值作为权重，并以此进行轮盘赌选择：重要性越高的特征被选中为划分特征的概率越大。改优化方法强调：并不是重要性越高的特征就一定会被选择成为划分特征，通过轮盘赌的方式能够保证初始种群生成的随机性，防止过早收敛于局部最优解。

\subsection{划分点选择的优化}

为避免节点划分严重不平衡的情况出现，本文采用基于正态分布的轮盘赌算法进行划分点的选取。在完成\ref{sec:SpliteFeature}的基础上，遍历被选中划分特征$\mathbf{p}$的在当前节点的所有有效取值（对于有效取值为连续变量得划分特征$\mathbf{p}$，间隔一定步长选取有效取值）作为划分点候选集合。以此遍历候选集合中的有效取值$v_p$，并以$v_p$作为划分点将当前节点中的数据集划分为左右两部分，左右两部分包含的数据量分别记为$D_L$，$D_R$，通过公式\ref{eq:ImbalanceCoefficient}计算出以当前有效取值$v_p$为划分点进行节点划分时的失衡系数$\phi$：

\begin{equation}\label{eq:ImbalanceCoefficient}
    \phi=\frac{2\delta(D_L-D_R)}{D_T(1.0-2P_{D_{min}})}
\end{equation}

其中，$\delta$是下面正态分布公式\ref{eq:NormalDistribute}中的标准差参数，$D_T$是当前节点持有的总数据量，$D_L$、$D_R$分别是划分后两部分含有的数据量，而$P_{D_{min}}$是由用户根据计算变量重要性需要的最少数据量确定的数据量最小阈值比例。

将该失衡系数$\phi(v)$作为自变量，按照如下正态分布公式\ref{eq:NormalDistribute}，可以计算出当前有效取值$v$作为最终划分点的概率：

\begin{equation}\label{eq:NormalDistribute}
    f(\phi)=\frac{1}{\sqrt{2\pi}\delta}e^{-\frac{\phi^2}{2\delta^2}}
\end{equation}

其中，$e$是自然指数，本文$\delta$取4.0，正态分布如图\ref{Fig.normalDistribute}所示：

\begin{figure}[!h]
	\centering{
	\includegraphics[width=1.0\linewidth]{figures/normalDistribute.png}}
	\caption{概率服从的正态分布.}
	\label{Fig.normalDistribute}
\end{figure}

所有有效取值被选中的概率作为轮盘赌的权重进行最终划分点的确定。本文通过该过程使得那些更有能力将数据划分更均衡的有效取值有更大几率成为划分点，从而尽可能防止数据的失衡划分。

\section{个体编码与解码}

\subsection{基本目标}

本文算法核心是完成对不同划分空间方案的统一编码抽象得到染色体，为遗传算子的实施提供具体载体，同时也需要完成根据染色体编码方式解码恢复出对应的空间划分方案，为适应度计算提供输入。

\subsection{编码}
\label{sec:Coding}

在阐述具体编码过程之前，需要明确进行统一编码的必要性，具体包括以下两点：

\begin{itemize}
    \item 本文算法所使用的染色体与个体一一对应，该染色体是个体的唯一标识。本文的个体类似自然界一倍体生物（仅有单条染色体），每个个体只仅拥有一个染色体组，且该染色体组中仅有一种类型的染色体，而不像绝大多数二倍体生物其每个个体拥有一对染色体组。这表明本文不采用生物有性繁殖其DNA双螺旋其解旋和重新组旋的过程，而假设单个染色体仅包含一条单链DNA。

    \item 遗传算子的交叉算子实际上是不同两个个体间等长的单链DNA 中等位基因之间的交换过程，详细过程参见\ref{sec:GAOperator}小节关于遗传算子的阐述。因此，本文算法要求能够对不同空间划分方案也就是不同形态的瓶颈分析树完成统一形态的编码，使得染色体之间能够顺利进行等位基因之间的交换操作。
\end{itemize}

进行编码最直接的想法是对空间划分结果本身：即划分得到的子空间进行编码以满足唯一标识该划分结果，但该编码方式的难点集中在如下两点：

\begin{itemize}
    \item 针对某一性能采样数据集所在的特征数据空间，划分方案有无穷多种。
    \item 同时，每种方案得到的子空间并不一定相同。
\end{itemize}

为了具体说明上述问题，图\ref{Fig.3_2}和图\ref{Fig.3_3}给出了特征空间仅包含两个特征（二维情况下）的简单解释。图中，$p_1$，$p_2$表示当前影响绘制时间$t$的特征属性，并且在该情况下仅有这两个特征会影响到绘制时间$t$，因此该问题的特征空间仅为一个二维空间。

\begin{figure}[!h]
	\centering{
	\includegraphics[width=1.0\linewidth]{figures/Fig_3_2.png}}
	\caption{划分子空间个数相同，划分方式不同.}
	\label{Fig.3_2}
\end{figure}

图\ref{Fig.3_2}(a)(b)中，均通过三次划分将原始数据空间划分为了4个子数据空间。红线表示第一次划分操作，图\ref{Fig.3_2}(a)显示其首次划分选取了$p_1$作为划分特征、$v_2$作为划分点，图\ref{Fig.3_2}(b)则显示其首次划分选取了$p_2$作为划分特征、$v_3$作为划分点进行。以此类推，蓝线和绿线分别表示第二次、第三次的划分操作，由图可知，图\ref{Fig.3_2}(a)和(b)在第二次和第三次划分时选取的划分特征和划分点并不一致，这造成了两种截然不同的划分方案。这表明即使特征空间仅包含两维特征，由于划分特征的先后顺序不相同、划分点取值不相同，对应得到的空间划分结果其数量也是十分庞大的。当研的特征空间维度逐渐增大时，这种情况的复杂度会呈现指数级的增长。

更进一步，图\ref{Fig.3_2}(a)(c)中，除第三次划分点的具体数值不相同以外，(a)(c)两种划分策略是基本相同的，尽管如此，由于划分点其具体取值往往数量级庞大，这将进一步造成划分方案数量的增加。

\begin{figure}[!h]
	\centering{
	\includegraphics[width=1.0\linewidth]{figures/Fig_3_3.png}}
	\caption{划分子空间个数不同，划分方式基本相同.}
	\label{Fig.3_3}
\end{figure}

图描述了在\ref{Fig.3_3}(a)的划分基础上，\ref{Fig.3_3}(b)有进行了第4次空间划分，这时原始数据空间被分别划分为了4个子空间和5个子空间。这对于统一编码来说是一个更加难以解决的问题。

受到图形学领域，如光线追踪技术中常用的kd树分层数据结构的启发，本文提出采用伪满二叉树的形式来表示对原始数据空间任意维度的划分处理以及结果表示，并依据该伪满二叉树进行统一编码。其关键思想是：

\begin{itemize}
    \item 采用二叉树表示划分过程和划分结果。
    \item 每个非叶节点n中都被认为隐式包含一个划分超平面，该划分超平面将数据集分成两部分。由前文所述，划分超平面可由数据对$(\mathbf{p}_n, \emph{p}_n)$唯一表示，其中$\mathbf{p}_n$是当前问题域特征空间中的某个特征，$\emph{p}_n$则是$\mathbf{p}_n$轴上任意的取值，以$\emph{p}_n$为划分点，该超平面垂直于$\mathbf{p}_n$轴。
    \item 空节点被引入到该二叉树中以构成逻辑意义上的“满二叉树”，即：伪满二叉树。假设伪满二叉树拥有相同的树高，则所有的划分方案就可以拥有统一的编码形式。
\end{itemize}

\begin{figure}[!h]
	\centering{
	\includegraphics[width=1.0\linewidth]{figures/Fig_3_4.png}}
	\caption{划分空间的对应伪满二叉树.}
	\label{Fig.3_4}
\end{figure}

如图\ref{Fig.3_4}所示，针对当前二维情况下的空间划分结果，首先通过超平面$(\mathbf{p}_1, \textit{p}_1)$将划分左右两部分，左侧部分包含的数据量实际上是由最终的子数据集(2)(3)(4) 构成的，右侧部分由子数据集(1)构成。而左侧部分仍通过超平面$(\mathbf{p}_2, \textit{p}_2)$进行了进一步的划分，以此类推直到划分到叶子节点。记得注意的是：在该例子中，伪满二叉树的最大树高被指定为(3)(4)节点所在的树高（树高为4），因此，为补齐一颗伪满二叉树，虚线部分所表示的空节点被引入。如果此时指定的伪满二叉树的最大树高为5 时，则(3)(4)节点的下方仍应该补齐两个左右空子节点。

\begin{figure}[!h]
	\centering{
	\includegraphics[width=1.0\linewidth]{figures/Fig_3_5.png}}
	\caption{编码后的染色体.}
	\label{Fig.3_5}
\end{figure}

如图\ref{Fig.3_5}所示，编码后的伪满二叉树储存在一个一维数组中，该数组即为本文所使用的染色体。该一维数组中的每个元素将通过如下的方式表示：根节点被存储在下标为0 的数组元素中；假设任意一个节点的下标为$i$，则其左右孩子节点将分别被存储在下标为$2i+1,2i+2$的数组元素中。

\begin{figure}[!h]
	\centering{
	\includegraphics[width=1.0\linewidth]{figures/Fig_3_6.png}}
	\caption{染色体内部信息.}
	\label{Fig.3_6}
\end{figure}

同时，如图\ref{Fig.3_6}所示，染色体内部需要记录的额外信息是当前非叶节点的划分超平面$(\textbf{p}_n, \textit{p}_n)$，即划分特征和划分点构成的数据对。通过上述操作可以编码得到一条染色体，其中每一个数组元素被称为基因，一条染色体实际上就是一种基因组合。

\subsection{解码}

根据染色体信息解码恢复出新个体的过程是必要的，原因是通过交叉算子、变异算子操作过后的染色体无法被直接评估其优质与否，必须通过将其恢复成为真正的瓶颈分析树个体，才能计算树中每个叶子节点的好坏，从而为整个个体的评判提供基础；

解码过程相对简单，需要完成以下过程：

\begin{itemize}
    \item 以预采集的性能数据集作为当前根节点的完整数据集，建立根节点，并从当前根节点开始，递归地完成接下来的操作。
    \item 找到当前节点对应的染色体下标index，根据当前下标取出染色体中存储的划分超平面信息，如果信息为空，则说明根据当前染色体指示，不再进行当前节点的继续划分，退出当前节点的划分工作；如果信息不为空，则根据取出的划分超平面信息，尝试将当前节点进行划分，如果按照该划分超平面划分得到的左右子节点均满足子节点拥有的最少数据量，则划分成功，其划分后的子节点同样完成步骤2中的操作，否则，当前的划分超平面失效，终止该节点的划分工作。
    \item 递归完成所有节点的划分工作，退出整个流程。
\end{itemize}

\section{适应度计算}
\label{sec:FitnessCalculate}

适应度评估对于遗传算法在种群迭代过程中起到了至关重要的作用。它决定了整个种群的进化方向，它引导着个体朝着提高种群整体适应度的方向发展。如公式\ref{eq:PartitionFitness}所示，个体适应度函数$F(\cdot)$表示某种将原始数据空间P 划分成n个子空间的划分方案的好坏程度，其中n个子空间分别表示为：$\mathcal{P}_0^{sub}, \mathcal{P}_1^{sub}, ..., \mathcal{P}_n^{sub}$。

\begin{equation}\label{eq:PartitionFitness}
	F(\mathcal{P}\rightarrow(\mathcal{P}_0^{sub}, \mathcal{P}_1^{sub}, ..., \mathcal{P}_n^{sub})) = \sum_{i=0}^n f(\mathcal{P}_i^{sub})
\end{equation}

其中，$f(\mathcal{P}_i^{sub})$表示子集$\mathcal{P}_i^{sub}$所在叶子节点的适应度函数，在之后的讨论中，$F(\cdot)$和$f(\cdot)$被称为个体适应度函数和叶子节点适应度函数。

经过前面的讨论，根据\cite{Zhang:2018:AIP:3208159.3208178}中关于瓶颈集的定义，只能得出一个布尔值的结果，即：当前叶子节点是否能够识别出瓶颈，这无法为进一步适应度的计算提供帮助。本文需要的是具有连续数值衡量标准的方法来获取当前叶子节点的好坏，无论该叶子节点能否识别出瓶颈集合，都应该拥有其相应的适应度函数得分（或者称为数值）。

事实上，在某个叶子节点能否识别出性能瓶颈只能作为评判叶子节点适应度好坏的充分不必要条件。也就是说，能够识别出性能瓶颈的叶子节点，计算其适应度函数的数值，它的得分一定是较高的，但是适应度函数数值的比较总是在相互比较重完成的，这表明适应度函数数值较高的叶子节点并不一定代表在它的数据集范围内找到了性能瓶颈。为进一步说明问题，本文列举了如下几种情况进行详细讨论：

\begin{figure}[!h]
	\centering{
	\includegraphics[width=1.0\linewidth]{figures/Fig_3_7.png}}
	\caption{子节点中均未识别出性能瓶颈.}
	\label{Fig.3_7}
\end{figure}

如图\ref{Fig.3_7}所示，即使在\ref{Fig.3_7}(a)和\ref{Fig.3_7}(b)上都无法确认识别出瓶颈，本文仍然认为图\ref{Fig.3_7}(b)的划分情况要优于\ref{Fig.3_7}(a)的划分情况。因为在\ref{Fig.3_7}(b)中各排序后的特征变量重要性数值的最大下降落差要大于\ref{Fig.3_7}(a)中的最大落差。

\begin{figure}[!h]
	\centering{
	\includegraphics[width=1.0\linewidth]{figures/Fig_3_8.png}}
	\caption{子节点中均识别出性能瓶颈.}
	\label{Fig.3_8}
\end{figure}

如图\ref{Fig.3_8}所示，即使\ref{Fig.3_8}(a)和\ref{Fig.3_8}(b)均识别到了瓶颈（红色部分表示识别到的瓶颈），本文依然认为\ref{Fig.3_8}(b)的划分情况比\ref{Fig.3_8}(a)的划分情况要好。这是因为在\ref{Fig.3_8}(b)中可以唯一确认出一个极度影响绘制性能的因素。
综上所述，本文将采用如下原则设计个体适应书函数$F(\cdot)$和叶子节点适应度函数$f(\cdot)$:

\begin{itemize}
    \item 采用连续性函数模型描述个体适应度函数$F(\cdot)$，保证任意两种划分方案顺利完成其适应度好坏的比较。
    \item 当前特征空间中所有特征的变量重要性数值VI以及其整体分布情况应该决定叶子节点变量重要性函数$f(\cdot)$的计算。具体来说，该原则包含两部分，第一部分要求在子数据集空间$\mathcal{P}^{sub}$中，重要的特征（即：公式\ref{eq:SubspaceFitness}中的重要参数，详细定义将在随后给出）的个数越趋近于1，则持有$\mathcal{P}^{sub}$的叶子节点其适应度函数计算结果越高；第二部分要求$f(\cdot)$的计算应与一个距离成正相关。这个距离为重要特征的变量重要性、不重要特征的变量重要性分别和平均变量重要性之间距离的绝对值之和。
    \item 子数据集空间$\mathcal{P}^{sub}$的数据量也应该被考虑进来以防止划分空间朝着最小数据集的方向发展。也就是说，本文并不希望瓶颈分析树的高度过于大，这意味着子空间个数的进一步增加，这不利于帮助开发人员进行整体优化工作
\end{itemize}

基于上述原理，本文设计公式\ref{eq:SubspaceFitness}描述$f(\mathcal{P}_i^{sub})$，该公式具体由三个因素决定：

\begin{equation}\label{eq:SubspaceFitness}
	f(\mathcal{P}^{sub}) = f_1(\mathcal{P}^{sub})*f_2(\mathcal{P}^{sub})*f_3(\mathcal{P}^{sub})
\end{equation}

其中$f_1(\mathcal{P}^{sub}), f_2(\mathcal{P}^{sub}), f_3(\mathcal{P}^{sub})$分别从3个不同的方面影响了$f(\mathcal{P}_i^{sub})$的最终计算数值，详细计算公式参见公式\ref{eq:DetailFitness}:

\begin{equation}\label{eq:DetailFitness}
\begin{cases}
	f_1(\mathcal{P}^{sub}) = w_1 * \frac{N-N_{sig}}{N-1}+ w_2 * \frac{N-N_{med}}{N-1}+ w_3 * \frac{n_{tri}}{N-1}\\
	f_2(\mathcal{P}^{sub}) = \sqrt[3]{1 - \frac{I_{tri}^{avg}}{I_{sig}^{avg}}}\\
	f_3(\mathcal{P}^{sub}) = \sqrt[3]{\frac{|\mathcal{P}^{sub}|}{|\mathcal{P}|}}
\end{cases}
\end{equation}

$f_1$用来描述处在不同重要程度的参数个数对$f(\cdot)$计算的影响。单纯将参数划分为重要和非重要参数并不是理想的方式，因此文本采用三段法的划分方式根据其重要程度对参数进行区分。如图\ref{Fig.3_9}所示，所有参数根据其变量重要性VI 的计算结果进行降序排序，假设$s_{max}$是当前子数据集$f(\mathcal{P}_i^{sub})$下最大VI值的具体数值，则区间$(0,s_{max}]$可以被划分为三个子区间：$(0, r_1*s_{max}], (r_1*s_{max}, r_2*s_{max}], (r_2*s_{max}, s_{max}]$，其中$r_1$和$r_2$是满足$0<r_1<r_2<1$的两个限制参数，由用户自定义决定。基于上述三个区间，所有参数可被相应的归为不同种类的参数：重要参数，灰色参数以及不重要参数。本文设置$r_1 = 0.25$，$r_2 = 0.75$。

$f2(\cdot)$通过重要参数的平均变量重要性与不重要变量重要性的平均变量重要性的比率印象影响$f(\cdot)$的计算结果；

$f3(\cdot)$用来控制划分子空间的个数。

在上述三个子公式中，本文认为$f1(\cdot)$在影响$f(\cdot)$计算时应该占有更重要的比重，因此在设计$f2(\cdot)$和$f3(\cdot)$时引入了开立方操作，以减少它们对$f(\cdot)$的影响。

\begin{figure}[!h]
	\centering{
	\includegraphics[width=1.0\linewidth]{figures/Fig_3_9.png}}
	\caption{三段划分方式.}
	\label{Fig.3_9}
\end{figure}

\section{遗传算子}
\label{sec:GAOperator}

\subsection{基本目标}

本章的基本目标是通过构建合理的遗传算子操作，生成并保留更优秀的种群个体，使得种群整体逐渐向更高适应度的方向收敛，直至收敛最优解。根据算法概述讨论可知，新一代种群是由上一代种群通过遗传算子操作得到的，因此，如何构建合理的遗传算子操作是本章关注的重点内容。

\subsection{选择算子}
\label{sec:GAOperatorSelector}

选择算子表示基于适应度的优胜略汰的过程。其具体表现在两个方面：一方面通过选择算子把优质个体直接遗传到下一代，另一方面，通过选择算子选择一定比例的个体通过配对交叉产生新的个体，这间接利用到选择算子，因此选择算子有时也被称作再生算子。

目前，常用的选择算子方法包括：随机遍历抽样法、局部选择法和适应度比例法。随机遍历抽样法表示在当前种群中，每个个体被选中的概率相等。由于它在进行选择操作时采用随机等概率的方式抽取个体，所以对不同适应度的个体机会均等，故可以认为种群多样性\cite{chenxiao2004Diversity}相对持久，但其缺点在于太过随机，导致整个种群的迭代规律不明显；在局部选择法中，通常表示在规模N 的个体中选取适应度数值最高的前$n$个个体（$n < N$），这使得适应度最好的前$n$个个体被完整的保留下来，而适应度处于末位的个体被直接淘汰，该方法改进了前一种方法种群迭代规律不明显的缺点，加快了种群收敛速度，但其缺点在于很容易产生超级个体，致使种群很容易快速收敛于一个局部最优解；而在适应度比例法该方法中，每个个体的被选中概率与其适应度和其适应度成比例，常用的比例模型为轮盘赌模型：假设当前种群的规模为n，每个个体用$i$表示$(i = 1, 2, …n)$，$p(i)$表示个体$i$被选中的概率，其计算公式参见\ref{eq:lotteGame}:

\begin{equation}\label{eq:lotteGame}
	p_i=\sqrt[c]{\frac{f_i}{\sum_{j=1}^{n}f_j}}
\end{equation}

显然，以这种方式得到的概率反映了个体$i$的适应度在整个种群个体适应度综合中所占的比例。个体适应度越大，其被选中的概率就越高，但并不表示一定会被选中，同时，本文进一步通过控制参数$c$来达到控制种群多样性的目的。

\subsection{交叉算子}
\label{sec:CrossoverOperator}

在详细阐述交叉算子操作之前，本文先解释何为交叉概率。交叉概率是指针对当前已经被选择出的两个用于交叉的双亲个体真正进行交叉操作的概率，也就是说，即使通过选择算子选择产生出一对用于交叉操作的双亲个体，该双亲个体也不一定真正执行交叉操作产生新的两个个体。\cite{wanglan}中研究并提出交叉概率在整个遗传迭代过程中如果保持恒定不变会降低遗传算法性能，作者表示迭代初期需要较大的交叉概率以造成种群的足够扰动，从而增强遗传算法的搜索能力，而在迭代后期采用更小的交叉概率以避免破坏已有优良基因。

本文采用公式\ref{eq:CrossOverPro}计算每代种群的双亲交叉概率:
\begin{equation}\label{eq:CrossOverPro}	
    P_c=(1.0-\frac{I_{cur}}{I_{max}})\sqrt{\frac{\sigma_{fit}^2+(F_{big}-F_{small})^2}{2*(F_{max}-F_{min})^2}}
\end{equation}

其中，$P_c$表示当前种群中某个双亲的交叉概率，$I_{cur}$表示当前种群的遗传迭代次数，$I_{max}$表示最大遗传迭代次数，$f_{max}$、$f_{min}$和$f_{avg}$分别表示当前整个种群中最大适应度值、最小适应度值和平均适应度值，$f_{cmax}$表示当前双亲的较大适应度值。该公式保证遗传算法收敛到最优解的性质在\cite{wanglan}中给出了详细的证明和数学推导。

交叉算子\cite{dengchun2009Crossover}根据交叉概率将种群中选取的两个个体随机的进行若干基因的交换，并产生新的两个染色体（基因组合），期望将有益基因组合在一起旨在产生更优秀的个体。具体有不同的交叉实现方案，主要包括：单点交叉、多点交叉、均匀交叉以及算数交叉等。

单点交叉是指在个体基因串中只随机设置一个交叉点，然后随机选择两个个体做为父代个体，相互交换它们交叉点后面的那部分基因块，然后产生两个新的子代个体；

多点交叉是指在个体基因串中随机设置多个交叉点，然后进行基因点交换，其操作过程与单点交叉相类似；

均匀交叉是指通过随机生成的、与基因长度等长的屏蔽串（0和1的串）指导子代个体继承父代基因的交叉方法。假设屏蔽字的第$i$位是0，那么子代个体$S_1$染色体第$i$位基因便继承父代个体$P_1$，子代个体$S_2$染色体第$i$位基因则继承父代个体$P_2$；反之，屏蔽字的第$i$位是1，子代个体$S_1$染色体第$i$位基因便继承父代个体$P_2$，子代个体$S_2$染色体第$i$位基因则继承父代个体$P_1$。

算数交叉是指由两个个体的线性组合而产生出两个新的个体。算术交叉的操作对象一般是由浮点数编码所表示的个体。

本文尝试采用单点交叉和多点交叉的方式完成交叉算子，而放弃算数交叉与均匀交叉。算数交叉通常适用于浮点数编码，使用该算子需要保证各特征的线性组合结果是有意义的，这与本文研究内容相悖。均匀交叉在种群迭代初期可以加快发现新的较优个体，具有较好的重组能力，但比较容易破坏已有好的结构，针对本文遇到的实际问题：本文算法不希望将已得到的好的瓶颈分析树分枝进行高频率的破坏，这种情况会容易丢失已获得的优质分枝同时增加重构瓶颈分析树的计算成本。

图\ref{Fig.3_10}(a)、\ref{Fig.3_10}(b)分别为单点、多点交叉示意图。单点交叉是指在参与交叉的两条染色体上仅选取一对等位基因进行交换的操作；多点交叉是指在参与交叉的两条染色体上选取多对等位基因进行交换的操作。这两种方式仅在选取交换基因的个数上有差异，具体根据不同的研究问题可以采取不同的交叉方式。本文会在实验部分验证采用哪种方案将更有利于解决本文关注的问题域。

\begin{figure}[!h]
	\centering{
	\includegraphics[width=.8\linewidth]{figures/Fig_3_10.png}}
	\caption{单点交叉与多点交叉.}
	\label{Fig.3_10}
\end{figure}

\subsection{变异算子}
\label{sec:GAOperatorMutex}

变异算子用来保证种群在迭代过程中的个体多样性，防止收敛速度过快导致的进化朝着局部最优解的方向进行。变异作为小概率事件在自然界的生物进化中起到不可替代的作用：变异的方向是完全不确定的，这是生物多样性的重要原因，由于方向的不确定性，变异个体可能更差，更差的个体通过本算法逐渐被淘汰，也可能更优，这为本算法产生优质个体提供了另外一种途径。

本文算法通过等概率随机选取种群个体，在此基础上等概率随机选择染色体的非叶节点基因，在该基因上进行其划分特征和划分点的等概率随机变化完成对随即变异的模拟。

\section{其他}

\subsection{等位基因交换失效}

瓶颈分析树的染色体存在等位基因交换失败的可能，其原因在于相同位置上的树节点并不一定同时存在。以图\ref{Fig.FailChange}为例说明等位基因交换失败的情况，$T_1$和$T_2$为两种不同划分形式的瓶颈分析树，假设树$T_1$的节点$A$、$B$均可划分，则$A$和$A'$交换失败的原因是$A'$节点不存在可交换的划分属性以及划分节点信息；而$B$和$B'$交换失败的原因是$B'$本身为空节点，也不存在交换的可能。

\begin{figure}[!h]
	\centering{
	\includegraphics[width=1.0\linewidth]{figures/FailChange.png}}
	\caption{等位基因交换失败.}
	\label{Fig.FailChange}
\end{figure}

一旦出现等位基因交换失败的情况出现，本文通过概率的方式决定是否再次进行交换基因点的选取，参见公式\ref{eq:Sigmoid}。
\begin{equation}\label{eq:Sigmoid}	
    \mathbf{p}(x) = 2(1 - \frac{1}{1+e^{-(x-1)}}), \ x \geq 1
\end{equation}
该公式是Sigmoid函数的变种，其中$x$表示已经交换失败的次数，首次交换失败后重新选取的概率为1，随着失败次数的增加，交换概率逐渐趋于0。

\subsection{种群序列化与反序列化}

为进一步降低种群训练的计算成本与时间成本，本文利用序列化与反序列化技术将算法生成的初始种群进行保存与再现。根据本文提出的算法流程，在算法起始阶段，会生成一定规模的初始种群，初始种群实际上是若干瓶颈分析树的集合，对初始种群的序列化主要对每个瓶颈分析树的序列化，考虑到序列化信息的压缩问题，本文并未直接对瓶颈分析树进行序列化，而是结合编码信息可以唯一确定一棵瓶颈分析树这一特性，将瓶颈分析树的编码信息和适应度信息进行序列化保存。其中序列化模型内具体保存染色体上各基因点上的划分特征信息、划分点信息、节点类型信息以及参数变量重要性信息。这些信息均是在种群初始化阶段计算得到的，然而每次重复生成这些信息所消耗的计算时间是十分可观的，并且初始种群的信息一旦生成便可重复利用。利用这些信息进行反序列过程可以迅速重建出原始的初始种群，这极大地提高了本文方法的分析效率。

\section{本章小结}

本章主要介绍了本文的主要工作，详细介绍了基于贪心策略和类遗传策略的复杂绘制系统性能识别算法其全部流程和具体实现细节。重点介绍类遗传策略，按照遗传算法的核心思想划分，首先对于初始种群的生成进行了详细的介绍，其次对种群个体的编码和解码方式进行了详细的阐述，推导其实现过程，之后根据本文研究的具体问题推导并设计了适应度函数，并进一步讨论了本文遗传算子的具体实现方式，最后对本文在完成具体算法时的其他工作进行了补充。